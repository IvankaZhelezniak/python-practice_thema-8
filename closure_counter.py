# створимо замикання, яке буде зберігати інформацію про кількість разів виклику функції.
from typing import Callable

def counter() -> Callable[[], int]:    # [] порожній список — значить, повернена функція не приймає параметрів; int — ця повернена функція повертає ціле число (int).
    count = 0

    def increment() -> int:
        # використовуємо nonlocal, щоб змінити змінну в замиканні
        nonlocal count  
        count += 1
        return count

    return increment

# Створення лічильника
count_calls = counter()

# Виклики лічильника
print(count_calls())  # Виведе 1
print(count_calls())  # Виведе 2
print(count_calls())  # Виведе 3

# Це приклад замикання, де increment замкнула в собі змінну count і має до неї доступ навіть після того, 
# як зовнішня функція counter завершує своє виконання. 
# Завдяки цьому, count_calls зберігає стан між викликами. 
# Кожен раз, коли ми викликаємо count_calls, вона викликає increment, яка замкнула в собі count.


# Так можна створити функцію, яка може змінювати поведінку в залежності від того скільки викликів вже відбулося.
