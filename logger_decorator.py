# Є такий шаблон проектування — декоратор. Цей шаблон полягає в тому, щоб розширювати функціонал який вже існує, 
# не вносячи змін в код цього самого функціоналу.

# Декоратори в Python — це дуже потужний і корисний інструмент, 
# який дозволяє змінювати поведінку функцій або методів без зміни їхнього вихідного коду. 
# Вони є прикладом функцій вищого порядку, які приймають іншу функцію як аргумент та повертають нову функцію.

# Наприклад, у нас є якась дуже складна і важлива функція complicated:
# def complicated(x: int, y: int) -> int:
#     return x + y

# І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логування до цієї функції, 
# виводити в консоль щоразу, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.

# Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:
def complicated(x: int, y: int) -> int:
    return x + y

def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

complicated = logger(complicated)
print(complicated(2, 3))

# Декоратор logger приймає функцію як аргумент і повертає нову функцію complicated = logger(complicated). 
# Декорована функція зберігає свою оригінальну функціональність, але додатково отримує нову поведінку або модифікації.

# Проте такий код не занадто легкий для читання і досить об'ємний. 
# Крім того, в коді легко пропустити рядок complicated = logger(complicated) 
# і не занадто просто зрозуміти, звідки виходитиме доданий до complicated функціонал.


# Спеціальний синтаксис декоратора - щоб спростити застосування цього шаблону проектування. 
# Декоратори використовуються з синтаксисом @, що робить їх застосування простим та елегантним. 
# Точно той самий код, який робить в точності те саме, можна записати у вигляді:

def logger(func):
    def inner(x: int, y: int) -> int:
        print(f"Викликається функція: {func.__name__}: {x}, {y}")
        result = func(x, y)
        print(f"Функція {func.__name__} завершила виконання: {result}")
        return result

    return inner

@logger
def complicated(x: int, y: int) -> int:
    return x + y

print(complicated(2, 3))
# Функція logger є декоратором. Вона приймає функцію func і повертає нову функцію inner. 
# Функція inner виконує додаткові дії (логування) до і після виконання func. 
# При оголошенні функції complicated, ми використовуємо @logger, щоб застосувати декоратор.
#  Тепер при кожному виклику complicated будуть виконуватися додаткові дії логування. 
# Тепер у коді явно видно, що complicated була задекорована logger у тому самому місці, де complicated була оголошена.
